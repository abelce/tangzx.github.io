<!DOCTYPE html><html lang="zh-Hans"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Mobx-state-tree介绍 - 文钦的个人日志</title><meta name="keywords" content="Mobx-state-tree,MST"/><meta property="og:title" content="Mobx-state-tree介绍 - 文钦的个人日志"/><meta property="og:url"/><meta name="next-head-count" content="6"/><meta name="baidu-site-verification" content="code-qLvQxBZOZA"/><meta name="google-site-verification" content="LE9f0-2YGlWDKgo5955hV_-oeN3Uq74EN_6gcKaJ60U"/><title>文钦的个人日志</title><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><meta http-equiv="Cache-Control" content="no-siteapp"/><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover"/><link rel="icon" href="/favicon.ico"/><meta name="author" content="1061225829@qq.com"/><meta property="og:type" content="website"/><meta property="site_name" content="文钦的个人日志"/><meta property="og:site_name" content="文钦的个人日志"/><link rel="dns-prefetch" href="cdn.vwood.xyz"/><link rel="dns-prefetch" href="cloud.vwood.xyz"/><meta name="baidu_union_verify" content="a673bc08063b1108073e80d745c6be14"/><script type="text/javascript" src="//cpro.baidustatic.com/cpro/ui/cm.js"></script><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6887995008287565" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/d03eec8081b86b18.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d03eec8081b86b18.css" data-n-g=""/><link rel="preload" href="/_next/static/css/4174f70b245a56f7.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4174f70b245a56f7.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-2f9cc031851afd5a.js" defer=""></script><script src="/_next/static/chunks/framework-0ba0ddd33199226d.js" defer=""></script><script src="/_next/static/chunks/main-8623703db73d68c8.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5ead76d55e25978e.js" defer=""></script><script src="/_next/static/chunks/216-7508e3954a0432df.js" defer=""></script><script src="/_next/static/chunks/pages/blogs/%5Bid%5D-0b6164d34e52f38c.js" defer=""></script><script src="/_next/static/6npVgWeWZ_y_dhFxNsFjp/_buildManifest.js" defer=""></script><script src="/_next/static/6npVgWeWZ_y_dhFxNsFjp/_ssgManifest.js" defer=""></script></head><body class="custom_class"><div id="__next"><section class="ant-layout ant-layout-has-sider style_layout__lI5tQ" id="layout"><header class="ant-layout-header"><div class="style_header__bLUBo"><nav class="style_header_left__3P86Z"><a class="style_logo-container__bUXun" href="/"><img alt="vwood" src="/images/logo.png"/></a><ul class="ant-menu-overflow ant-menu ant-menu-root ant-menu-horizontal ant-menu-light style_navs__cT4uk" role="menu" tabindex="0" data-menu-list="true"><li class="ant-menu-overflow-item ant-menu-item ant-menu-item-only-child style_nav-item__36GBG" style="opacity:1;order:0" role="menuitem" tabindex="-1"><span class="ant-menu-title-content">文章</span></li><li class="ant-menu-overflow-item ant-menu-item ant-menu-item-only-child style_nav-item__36GBG" style="opacity:1;order:1" role="menuitem" tabindex="-1"><span class="ant-menu-title-content">更新日志</span></li><li class="ant-menu-overflow-item ant-menu-overflow-item-rest ant-menu-submenu ant-menu-submenu-horizontal" style="opacity:0;height:0;overflow-y:hidden;order:9007199254740991;pointer-events:none;position:absolute" aria-hidden="true" role="none"><div role="menuitem" class="ant-menu-submenu-title" tabindex="-1" aria-expanded="false" aria-haspopup="true"><span role="img" aria-label="ellipsis" class="anticon anticon-ellipsis"><svg viewBox="64 64 896 896" focusable="false" data-icon="ellipsis" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z"></path></svg></span><i class="ant-menu-submenu-arrow"></i></div></li></ul><div style="display:none" aria-hidden="true"></div></nav><nav class="style_header_right__66ICX"></nav></div></header><main class="ant-layout-content style_layout-content__nrtXO"><div class="style_detail_container__YiTh1"><div class="style_content__kMJ4y"><div class="style_post_container__xy1dg"><div class="style_post__STttj"><div class="style_post_content__LiFhd"><div class="style_post_header__yefRf"><h1 class="style_name__IG9VL">Mobx-state-tree介绍</h1><div class="style_base-info__kvLMe"><span class="style_item__m96GX"><i class="iconfont"></i><span>发表于 <!-- -->2022-05-23</span><div class="ant-divider ant-divider-vertical" role="separator"></div><span>更新于 <!-- -->2022-06-22</span><div class="ant-divider ant-divider-vertical" role="separator"></div><span class="view_view__gVK9p"><span>阅读量 </span><span>178</span></span></span><div></div></div></div><div><div class="style_content__kMJ4y"><div class="style_marked__AZOQ3"><div class="markdown-body"><h3 id="介绍">介绍</h3>
<p>Mobx-state-tree（简称MST）是基于mobx的响应式状态管理工具，核心思想就是一个动态树，每个树由一个结构和一个状态组成，支持状态的序列化、反序列化、时间旅行等功能。</p>
<h3 id="使用">使用</h3>
<pre><code class="language-js">npm install mobx mobx-state-tree --save</code></pre>
<p>或</p>
<pre><code class="language-js">yarn add mobx mobx-state-tree</code></pre>
<h3 id="types">types</h3>
<p>如下是一个后端对象结构描述，前端怎么保证数据类型的一致性。或者是修改时过程中数据类型不会发生变化</p>
<pre><code class="language-go"><span class="hljs-keyword">type</span> Article <span class="hljs-keyword">struct</span> {
    ID         <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;id&quot;`</span>        <span class="hljs-comment">// 文章ID</span>
    Name       <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span>      <span class="hljs-comment">// 文章名称</span>
    CreateTime <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;createTime`</span> <span class="hljs-comment">// 创建时间</span>
    IsDeleted  <span class="hljs-type">bool</span>   <span class="hljs-string">`json:&quot;isDeleted&quot;`</span> <span class="hljs-comment">// 是否删除</span>
}</code></pre>
<p>MST提供了一个类型校验机制，通过设置类型就可以定义整个状态的树形结构。在开发的时候就可以判断类型是否匹配并提前给出错误提示。</p>
<p>MST提供了一个<a href="https://mobx-state-tree.js.org/overview/types">types</a> 的对象，其中包含基础类型：</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>integer</li>
<li>Date</li>
</ul>
<p>工厂方法：</p>
<ul>
<li>model</li>
<li>array</li>
<li>map</li>
<li>optional</li>
</ul>
<p>其中<strong>model</strong>用来创建Model，在model中可以包含多个type，通过type的组合就可以定义出整颗状态树。</p>
<p>Model定义好后，使用Model.create创建实例，传入的第一个参数作为默认值，如果没传将使用optional中设定的值作为默认值；第二个个参数为可选参数（环境配置对象env），通过env实现依赖注入。<a href="https://codesandbox.io/s/thirsty-hill-5fo01d?file=/src/mst.js">demo</a></p>
<pre><code class="language-js"><span class="hljs-comment">// 文章model</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Article</span> = types
  .<span class="hljs-title function_">model</span>(<span class="hljs-string">&quot;Article&quot;</span>, {
    <span class="hljs-attr">id</span>: types.<span class="hljs-property">string</span>,
    <span class="hljs-attr">name</span>: types.<span class="hljs-property">string</span>,
    <span class="hljs-attr">createTime</span>: types.<span class="hljs-property">integer</span>,
    <span class="hljs-attr">isDeleted</span>: types.<span class="hljs-title function_">optional</span>(types.<span class="hljs-property">boolean</span>, <span class="hljs-literal">false</span>)
  })
    .<span class="hljs-title function_">actions</span>(<span class="hljs-function">(<span class="hljs-params">self</span>) =&gt;</span> ({
    <span class="hljs-attr">setName</span>: <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
      self.<span class="hljs-property">name</span> = value;
    }
  }))

<span class="hljs-comment">// 文章实例</span>
<span class="hljs-keyword">const</span> article = <span class="hljs-title class_">Article</span>.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;1&quot;</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;测试&quot;</span>,
  <span class="hljs-attr">createTime</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()
});
<span class="hljs-comment">// 文章列表model</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ArticleList</span> = types.<span class="hljs-title function_">model</span>(<span class="hljs-string">&quot;ArticleList&quot;</span>, {
  <span class="hljs-attr">list</span>: types.<span class="hljs-title function_">array</span>(<span class="hljs-title class_">Article</span>),
  <span class="hljs-attr">current</span>: types.<span class="hljs-title function_">reference</span>(<span class="hljs-title class_">Article</span>)
});</code></pre>
<p>上面创建了两个model <strong>Article</strong>、<strong>AritcleList</strong>，虽然代码看起来有点繁琐，但是比起将状态放在store中，粒度其实更小了，可以更好的复用。</p>
<p>当通过<strong>setName</strong>方法设置name的值时，不是string类型就回报错</p>
<pre><code class="language-js">article.<span class="hljs-title function_">setName</span>(<span class="hljs-number">123</span>)</code></pre>
<pre><code>Error
[mobx-state-tree] Error while converting `123` to `string`:

    value `123` is not assignable to type: `string` (Value is not a string).</code></pre><p>设置默认值，使用<strong>optional</strong>可以给字段设置默认值</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Article</span> = types
  .<span class="hljs-title function_">model</span>({
    <span class="hljs-attr">id</span>: types.<span class="hljs-property">string</span>,
    <span class="hljs-attr">name</span>: types.<span class="hljs-property">string</span>,
    <span class="hljs-attr">createTime</span>: types.<span class="hljs-property">integer</span>,
    <span class="hljs-attr">isDeleted</span>: types.<span class="hljs-title function_">optional</span>(types.<span class="hljs-property">boolean</span>, <span class="hljs-literal">false</span>)
  })</code></pre>
<h3 id="props">props</h3>
<p>props指的是Model中定义的属性，定义了model包含哪些字段、以及对应的类型。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Article</span> = types
  .<span class="hljs-title function_">model</span>(<span class="hljs-string">&quot;Article&quot;</span>, {
    <span class="hljs-attr">name</span>: types.<span class="hljs-property">string</span>,
    <span class="hljs-attr">isDeleted</span>: types.<span class="hljs-title function_">optional</span>(types.<span class="hljs-property">boolean</span>, <span class="hljs-literal">true</span>)
  })</code></pre>
<p>第一个参数为Model的名称，第二个参数就是props。model的第二个参数可以省略，如下:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Article</span> = types
  .<span class="hljs-title function_">model</span>(<span class="hljs-string">&quot;Article&quot;</span>)
  .<span class="hljs-title function_">props</span>({
    <span class="hljs-attr">name</span>: types.<span class="hljs-property">string</span>,
    <span class="hljs-attr">isDeleted</span>: types.<span class="hljs-title function_">optional</span>(types.<span class="hljs-property">boolean</span>, <span class="hljs-literal">true</span>)
  })</code></pre>
<p>定义好props之后，可以直接访问到对应的字段</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> article = <span class="hljs-title class_">Article</span>.<span class="hljs-title function_">create</span>({<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;测试&quot;</span>,});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(article.<span class="hljs-property">name</span>);</code></pre>
<p>当数据需要通过计算得到时可以使用Views</p>
<h3 id="views">Views</h3>
<p>views是Model中定义或获取衍生数据的方法的集合，只能获取值不能设置值</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Article</span> = types
  .<span class="hljs-title function_">model</span>(<span class="hljs-string">&quot;Article&quot;</span>, {
    <span class="hljs-attr">id</span>: types.<span class="hljs-property">string</span>,
    <span class="hljs-attr">name</span>: types.<span class="hljs-property">string</span>,
    <span class="hljs-attr">createTime</span>: types.<span class="hljs-property">integer</span>,
    <span class="hljs-attr">count</span>: types.<span class="hljs-title function_">optional</span>(types.<span class="hljs-property">integer</span>, <span class="hljs-number">1</span>),
    <span class="hljs-attr">isDeleted</span>: types.<span class="hljs-title function_">optional</span>(types.<span class="hljs-property">boolean</span>, <span class="hljs-literal">true</span>)
  })
.<span class="hljs-title function_">views</span>(<span class="hljs-function">(<span class="hljs-params">self</span>) =&gt;</span> ({
    <span class="hljs-keyword">get</span> <span class="hljs-title function_">formatedName</span>() {
      <span class="hljs-keyword">return</span> self.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;_&quot;</span> + self.<span class="hljs-property">id</span>;
    },
    <span class="hljs-title function_">getFormatedName</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> self.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;_&quot;</span> + self.<span class="hljs-property">id</span>;
    }    
  }))</code></pre>
<p>上面使用的是getter的形式获取数据，数据将会被缓存直到依赖的数据发生变化。否则每次都需要通过函数调用的方式来获取数据，无法对计算结果进行缓存，<strong>推荐使用getter的方式，提升性能</strong>。</p>
<h3 id="actions">Actions</h3>
<p>MST在安全模式下不能直接修改属性的值，必须通过action， 否则会报错</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Article</span> = types
  .<span class="hljs-title function_">model</span>(<span class="hljs-string">&quot;Article&quot;</span>, {
    <span class="hljs-attr">name</span>: types.<span class="hljs-property">string</span>,
    ))
  .<span class="hljs-title function_">actions</span>(<span class="hljs-function">(<span class="hljs-params">self</span>) =&gt;</span> ({
    <span class="hljs-attr">setName</span>: <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
      self.<span class="hljs-property">name</span> = value;
    },
  }));
<span class="hljs-keyword">const</span> article = <span class="hljs-title class_">Article</span>.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;测试&quot;</span>
})
article.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&quot;123&quot;</span>);</code></pre>
<p>可以通过<strong>unprotect</strong>解除安全模式，解除后可能造成代码的不规范。</p>
<pre><code class="language-js"><span class="hljs-title function_">unprotect</span>(<span class="hljs-title class_">Article</span>);
article.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;123&quot;</span>;</code></pre>
<h4 id="生命周期"><a href="https://mobx-state-tree.js.org/overview/hooks">生命周期</a></h4>
<p>MST在提供了一些特殊的actions作为生命周期钩子</p>
<ul>
<li>afterCreate: 实例创建成功后</li>
<li>afterAttach：子节点</li>
<li>beforeDetach</li>
<li>beforeDestroy</li>
<li>....</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Article</span> = types
  .<span class="hljs-title function_">model</span>(<span class="hljs-string">&quot;Article&quot;</span>, {
    <span class="hljs-comment">// ....</span>
  })
  .<span class="hljs-title function_">actions</span>(<span class="hljs-function">(<span class="hljs-params">self</span>) =&gt;</span> ({
    <span class="hljs-attr">afterCreate</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(self);
    }
  }));
</code></pre>
<h3 id="快照">快照</h3>
<p>快照是状态树中特定时间点、固定的、序列化的对像，不包含类型信息，同时不可变。</p>
<p>在数据修改前可以保存数据的原始状态，然后根据快照来恢复状态，可以在表单修改前做一个快照，重置的时候直接从快照获取，避免再次请求后端接口。</p>
<p>常用方法：</p>
<ul>
<li>getSnapshot(model): 返回当前model的快照</li>
<li>applySnapshot(model, snapshot): 使用快照更新model的状态</li>
<li>onSnapshot(model, snapshot): 用来监听是否有新快照可用，自动生成快照。</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { getSnapshot, applySnapshot } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-state-tree&quot;</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Model</span> = types.<span class="hljs-title function_">model</span>(<span class="hljs-string">&quot;Article&quot;</span>, {
    <span class="hljs-comment">// ....</span>
  });
<span class="hljs-keyword">const</span> inst = <span class="hljs-title class_">Model</span>.<span class="hljs-title function_">create</span>(...);

<span class="hljs-comment">// 快照</span>
<span class="hljs-keyword">let</span> snapshot = <span class="hljs-title function_">getSnapshot</span>(inst);
<span class="hljs-comment">// 恢复</span>
<span class="hljs-title function_">applySnapshot</span>(model, snapshot);
</code></pre>
<p>通过快照可以自动比较变更过的字段，实现数据的增量提交。</p>
<p>PS：snapshot中数据的类型需要跟props定义的类型相同。</p>
<h3 id="volatile-state">Volatile state</h3>
<p>在MST中props定义了状态的类型，数据必须跟状态相匹配，并且数据可以导出为标准的JSON对象。如果无法预知数据的结构或类型，可以使用 <strong>volatile</strong>。</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { types } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-state-tree&quot;</span>;
<span class="hljs-keyword">import</span> { autorun } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Article</span> = types
  .<span class="hljs-title function_">model</span>({})
  .<span class="hljs-title function_">volatile</span>(<span class="hljs-function">(<span class="hljs-params">self</span>) =&gt;</span> ({
    <span class="hljs-attr">localState</span>: <span class="hljs-number">1</span>
  }))
  .<span class="hljs-title function_">actions</span>(<span class="hljs-function">(<span class="hljs-params">self</span>) =&gt;</span> ({
    <span class="hljs-title function_">setX</span>(<span class="hljs-params">value</span>) {
      self.<span class="hljs-property">localState</span> = value;
    }
  }));

<span class="hljs-keyword">const</span> article = <span class="hljs-title class_">Article</span>.<span class="hljs-title function_">create</span>();

<span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(article.<span class="hljs-property">localState</span>));

article.<span class="hljs-title function_">setX</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;lisi&quot;</span>
});</code></pre>
<p>当修改数据的时候<strong>localState</strong>的值被打印出来了，说明<strong>localState</strong>也是<strong>Observable</strong>的。</p>
<h3 id="类型校验原理">类型校验原理</h3>
<blockquote>
<p>MST类型校验的原理概括就是数据要发生改变时校验新值的类型是否匹配，不匹配就报错。</p>
</blockquote>
<p>下面以types.integer类型为例，代码如下</p>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">integer</span>: <span class="hljs-title class_">ISimpleType</span>&lt;number&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CoreType</span>&lt;number, number, number&gt;(
    <span class="hljs-string">&quot;integer&quot;</span>,
    <span class="hljs-title class_">TypeFlags</span>.<span class="hljs-property">Integer</span>,
    <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-title function_">isInteger</span>(v)
)</code></pre>
<p>integer是通过 <strong>CoreType</strong>创建的，其中有一个包含：create、instantiate、validate、isValidSnapshot等方法。</p>
<p>执行create方法时，会调用 <strong>instantiate</strong> 方法创建所有子节点(ObjectNode)，每一种类型都会实现instantiate ，并且在validate方法中调用isValidSnapshot方法，</p>
<pre><code class="language-js">    <span class="hljs-title function_">isValidSnapshot</span>(<span class="hljs-attr">value</span>: C, <span class="hljs-attr">context</span>: <span class="hljs-title class_">IValidationContext</span>): <span class="hljs-title class_">IValidationResult</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPrimitive</span>(value) &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">checker</span>(value <span class="hljs-keyword">as</span> any)) {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">typeCheckSuccess</span>()
        }
        <span class="hljs-keyword">const</span> typeName = <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> === <span class="hljs-string">&quot;Date&quot;</span> ? <span class="hljs-string">&quot;Date or a unix milliseconds timestamp&quot;</span> : <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">typeCheckFailure</span>(context, value, <span class="hljs-string">`Value is not a <span class="hljs-subst">${typeName}</span>`</span>)
    }</code></pre>
<p>这里的checker就是上面传入的 <strong>(v) =&gt; isInteger(v)</strong>。</p>
<p>model中会对实例添加拦截器(willChange)，在子节点的value发生改变前检查类型是否正确，其中typecheckInternal最终会调用到type.validate方法，最后调用isInteger方法</p>
<pre><code class="language-js">    private <span class="hljs-title function_">willChange</span>(<span class="hljs-attr">chg</span>: <span class="hljs-title class_">IObjectWillChange</span>): <span class="hljs-title class_">IObjectWillChange</span> | <span class="hljs-literal">null</span> {
        <span class="hljs-keyword">const</span> change = chg <span class="hljs-keyword">as</span> <span class="hljs-title class_">IObjectWillChange</span> &amp; { newValue?: any }

        <span class="hljs-keyword">const</span> node = <span class="hljs-title function_">getStateTreeNode</span>(change.<span class="hljs-property">object</span>)
        <span class="hljs-keyword">const</span> subpath = change.<span class="hljs-property">name</span> <span class="hljs-keyword">as</span> string
        node.<span class="hljs-title function_">assertWritable</span>({ subpath })
        <span class="hljs-keyword">const</span> childType = (node.<span class="hljs-property">type</span> <span class="hljs-keyword">as</span> <span class="hljs-variable language_">this</span>).<span class="hljs-property">properties</span>[subpath]
        <span class="hljs-comment">// only properties are typed, state are stored as-is references</span>
        <span class="hljs-keyword">if</span> (childType) {
            <span class="hljs-title function_">typecheckInternal</span>(childType, change.<span class="hljs-property">newValue</span>)
                        <span class="hljs-comment">// ....</span>
        }
        <span class="hljs-keyword">return</span> change
    }</code></pre>
<iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:800px; height:245px;" src="https://www.processon.com/embed/62a6961807912939b2287f8e"></iframe></div></div></div></div><div class="style_operations__XtOI_"></div></div></div></div><section class="style_comments__qH5Mz"></section></div><div class="style_latest__9fywH"><ul></ul></div></div></main><footer class="ant-layout-footer"><div class="style_footer__9WRvE"><div class="style_item__wDXtJ"><h2>联系</h2><div><div><div><a href="mailto:1061225829@qq.com">邮箱：1061225829@qq.com</a></div></div></div></div><div class="style_item__wDXtJ"><h2>vwood</h2><div><div><div class="style_about__2YCeI"><span>©2020 vwood</span><div class="ant-divider ant-divider-vertical" role="separator"></div><a href="/about">关于</a></div></div><div><div class="style_beian__sifwE"><span></span><a href="http://beian.miit.gov.cn/" target="_blank">蜀ICP备19030923号-1</a></div></div></div></div></div></footer><div class="ant-back-top"></div></section><div class="ant-back-top"></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"content":"### 介绍\n\nMobx-state-tree（简称MST）是基于mobx的响应式状态管理工具，核心思想就是一个动态树，每个树由一个结构和一个状态组成，支持状态的序列化、反序列化、时间旅行等功能。\n\n### 使用\n```js\nnpm install mobx mobx-state-tree --save\n```\n或\n```js\nyarn add mobx mobx-state-tree\n```\n\n### types\n如下是一个后端对象结构描述，前端怎么保证数据类型的一致性。或者是修改时过程中数据类型不会发生变化\n\n```go\ntype Article struct {\n\tID         string `json:\"id\"`        // 文章ID\n\tName       string `json:\"name\"`      // 文章名称\n\tCreateTime int64  `json:\"createTime` // 创建时间\n\tIsDeleted  bool   `json:\"isDeleted\"` // 是否删除\n}\n```\n\nMST提供了一个类型校验机制，通过设置类型就可以定义整个状态的树形结构。在开发的时候就可以判断类型是否匹配并提前给出错误提示。\n\nMST提供了一个[types](https://mobx-state-tree.js.org/overview/types) 的对象，其中包含基础类型：\n\n+ string\n+ number\n+ boolean\n+ integer\n+ Date\n\n工厂方法：\n\n+ model\n+ array\n+ map\n+ optional\n\n其中**model**用来创建Model，在model中可以包含多个type，通过type的组合就可以定义出整颗状态树。\n\nModel定义好后，使用Model.create创建实例，传入的第一个参数作为默认值，如果没传将使用optional中设定的值作为默认值；第二个个参数为可选参数（环境配置对象env），通过env实现依赖注入。[demo](https://codesandbox.io/s/thirsty-hill-5fo01d?file=/src/mst.js)\n\n```js\n// 文章model\nconst Article = types\n  .model(\"Article\", {\n    id: types.string,\n    name: types.string,\n    createTime: types.integer,\n    isDeleted: types.optional(types.boolean, false)\n  })\n\t.actions((self) =\u003e ({\n    setName: (value) =\u003e {\n      self.name = value;\n    }\n  }))\n\n// 文章实例\nconst article = Article.create({\n  id: \"1\",\n  name: \"测试\",\n  createTime: new Date().getTime()\n});\n// 文章列表model\nconst ArticleList = types.model(\"ArticleList\", {\n  list: types.array(Article),\n  current: types.reference(Article)\n});\n```\n\n上面创建了两个model **Article**、**AritcleList**，虽然代码看起来有点繁琐，但是比起将状态放在store中，粒度其实更小了，可以更好的复用。\n\n当通过**setName**方法设置name的值时，不是string类型就回报错\n\n```js\narticle.setName(123)\n```\n\n```\nError\n[mobx-state-tree] Error while converting `123` to `string`:\n\n    value `123` is not assignable to type: `string` (Value is not a string).\n```\n\n设置默认值，使用**optional**可以给字段设置默认值\n\n```js\nconst Article = types\n  .model({\n    id: types.string,\n    name: types.string,\n    createTime: types.integer,\n    isDeleted: types.optional(types.boolean, false)\n  })\n```\n\n\n\n### props\n\nprops指的是Model中定义的属性，定义了model包含哪些字段、以及对应的类型。\n\n```js\nconst Article = types\n  .model(\"Article\", {\n    name: types.string,\n    isDeleted: types.optional(types.boolean, true)\n  })\n```\n\n第一个参数为Model的名称，第二个参数就是props。model的第二个参数可以省略，如下:\n\n```js\nconst Article = types\n  .model(\"Article\")\n  .props({\n    name: types.string,\n    isDeleted: types.optional(types.boolean, true)\n  })\n```\n\n定义好props之后，可以直接访问到对应的字段\n\n```js\nconst article = Article.create({name: \"测试\",});\nconsole.log(article.name);\n```\n\n当数据需要通过计算得到时可以使用Views\n\n\n\n### Views\n\nviews是Model中定义或获取衍生数据的方法的集合，只能获取值不能设置值\n\n```js\nconst Article = types\n  .model(\"Article\", {\n    id: types.string,\n    name: types.string,\n    createTime: types.integer,\n    count: types.optional(types.integer, 1),\n    isDeleted: types.optional(types.boolean, true)\n  })\n.views((self) =\u003e ({\n    get formatedName() {\n      return self.name + \"_\" + self.id;\n    },\n\tgetFormatedName() {\n      return self.name + \"_\" + self.id;\n    }    \n  }))\n```\n\n上面使用的是getter的形式获取数据，数据将会被缓存直到依赖的数据发生变化。否则每次都需要通过函数调用的方式来获取数据，无法对计算结果进行缓存，**推荐使用getter的方式，提升性能**。\n\n### Actions\n\nMST在安全模式下不能直接修改属性的值，必须通过action， 否则会报错\n\n```js\nconst Article = types\n  .model(\"Article\", {\n    name: types.string,\n    ))\n  .actions((self) =\u003e ({\n    setName: (value) =\u003e {\n      self.name = value;\n    },\n  }));\nconst article = Article.create({\n  name: \"测试\"\n})\narticle.setName(\"123\");\n```\n\n可以通过**unprotect**解除安全模式，解除后可能造成代码的不规范。\n\n```js\nunprotect(Article);\narticle.name = \"123\";\n```\n\n\n\n#### [生命周期](https://mobx-state-tree.js.org/overview/hooks)\n\nMST在提供了一些特殊的actions作为生命周期钩子\n\n+ afterCreate: 实例创建成功后\n+ afterAttach：子节点\n+ beforeDetach\n+ beforeDestroy\n+ ....\n\n```js\nconst Article = types\n  .model(\"Article\", {\n    // ....\n  })\n  .actions((self) =\u003e ({\n    afterCreate: () =\u003e {\n      console.log(self);\n    }\n  }));\n\n```\n\n\n\n### 快照\n\n快照是状态树中特定时间点、固定的、序列化的对像，不包含类型信息，同时不可变。\n\n在数据修改前可以保存数据的原始状态，然后根据快照来恢复状态，可以在表单修改前做一个快照，重置的时候直接从快照获取，避免再次请求后端接口。\n\n常用方法：\n\n+ getSnapshot(model): 返回当前model的快照\n+ applySnapshot(model, snapshot): 使用快照更新model的状态\n+ onSnapshot(model, snapshot): 用来监听是否有新快照可用，自动生成快照。\n\n```js\nimport { getSnapshot, applySnapshot } from \"mobx-state-tree\";\n\nconst Model = types.model(\"Article\", {\n    // ....\n  });\nconst inst = Model.create(...);\n\n// 快照\nlet snapshot = getSnapshot(inst);\n// 恢复\napplySnapshot(model, snapshot);\n\n```\n通过快照可以自动比较变更过的字段，实现数据的增量提交。\n\nPS：snapshot中数据的类型需要跟props定义的类型相同。\n\n### Volatile state\n\n在MST中props定义了状态的类型，数据必须跟状态相匹配，并且数据可以导出为标准的JSON对象。如果无法预知数据的结构或类型，可以使用 **volatile**。\n\n```js\nimport { types } from \"mobx-state-tree\";\nimport { autorun } from \"mobx\";\n\nconst Article = types\n  .model({})\n  .volatile((self) =\u003e ({\n    localState: 1\n  }))\n  .actions((self) =\u003e ({\n    setX(value) {\n      self.localState = value;\n    }\n  }));\n\nconst article = Article.create();\n\nautorun(() =\u003e console.log(article.localState));\n\narticle.setX({\n  name: \"lisi\"\n});\n```\n\n当修改数据的时候**localState**的值被打印出来了，说明**localState**也是**Observable**的。\n\n### 类型校验原理\n\n\u003e MST类型校验的原理概括就是数据要发生改变时校验新值的类型是否匹配，不匹配就报错。\n\n下面以types.integer类型为例，代码如下\n\n```js\nexport const integer: ISimpleType\u003cnumber\u003e = new CoreType\u003cnumber, number, number\u003e(\n    \"integer\",\n    TypeFlags.Integer,\n    (v) =\u003e isInteger(v)\n)\n```\n\ninteger是通过 **CoreType**创建的，其中有一个包含：create、instantiate、validate、isValidSnapshot等方法。\n\n执行create方法时，会调用 **instantiate** 方法创建所有子节点(ObjectNode)，每一种类型都会实现instantiate ，并且在validate方法中调用isValidSnapshot方法，\n\n```js\n    isValidSnapshot(value: C, context: IValidationContext): IValidationResult {\n        if (isPrimitive(value) \u0026\u0026 this.checker(value as any)) {\n            return typeCheckSuccess()\n        }\n        const typeName = this.name === \"Date\" ? \"Date or a unix milliseconds timestamp\" : this.name\n        return typeCheckFailure(context, value, `Value is not a ${typeName}`)\n    }\n```\n\n这里的checker就是上面传入的 **(v) =\u003e isInteger(v)**。\n\nmodel中会对实例添加拦截器(willChange)，在子节点的value发生改变前检查类型是否正确，其中typecheckInternal最终会调用到type.validate方法，最后调用isInteger方法\n\n```js\n    private willChange(chg: IObjectWillChange): IObjectWillChange | null {\n        const change = chg as IObjectWillChange \u0026 { newValue?: any }\n\n        const node = getStateTreeNode(change.object)\n        const subpath = change.name as string\n        node.assertWritable({ subpath })\n        const childType = (node.type as this).properties[subpath]\n        // only properties are typed, state are stored as-is references\n        if (childType) {\n            typecheckInternal(childType, change.newValue)\n\t\t\t\t\t\t// ....\n        }\n        return change\n    }\n```\n\n\u003ciframe id=\"embed_dom\" name=\"embed_dom\" frameborder=\"0\" style=\"display:block;width:800px; height:245px;\" src=\"https://www.processon.com/embed/62a6961807912939b2287f8e\"\u003e\u003c/iframe\u003e","createTime":1653301833072,"description":" 介绍\n\nMobx-state-tree（简称MST）是基于mobx的响应式状态管理工具，核心思想就是一个动态树，每个树由一个结构和一个状态组成，支持状态的序列化、反序列化、时间旅行等功能。\n\n 使用\njs\nnpm install mobx mobx-state-tree --save\n\n或\njs\nyarn add mobx mobx-state-tree\n\n\n","id":"fbf0032a-b12f-422e-b042-e2b2f76bd7d8","isDeleted":false,"likeCount":0,"name":"Mobx-state-tree介绍","operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["Mobx-state-tree","MST"],"updateTime":1655884512933,"viewCount":178},"id":"fbf0032a-b12f-422e-b042-e2b2f76bd7d8"},"blogs":[{"content":"","createTime":1655824065596,"description":"事件发布/订阅是常用的一种模式，可以通过监听触发事件降低代码的复杂度。有很多开源的npm库可以使用，也可以尝试手写一个。\n\n 常用方法\n+ on(eventName, listener): 注册事件\n+ off(eventName, listener):  删除事件\n+ dispatch(eventName, ...params): 触发事件\n\n 原理\n原理主要是将事件回调添加(on)","id":"0257e379-878d-465a-b88a-03996f336035","isDeleted":false,"likeCount":0,"name":"手写事件监听模块","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["event","事件监听"],"updateTime":1656380254695,"viewCount":90},{"content":"","createTime":1655801108776,"description":"通过border来实现。\n1. \u003ccode\u003eborder: 40px solid transparent\u003c/code\u003e设置border的宽度和样式。\n2. \u003ccode\u003eborder-top-width\u003c/code\u003e设置顶部的border宽度为0。\n3. \u003ccode\u003eborder-bottom-color: ff0000\u003c/code\u003e设置底部border的颜色为红色\ncss\nwidth: 0","id":"020be9da-928a-40c9-b25a-fda6e1c182b1","isDeleted":false,"likeCount":0,"name":"css实现三角形","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["三角行","css"],"updateTime":1655971274067,"viewCount":59},{"content":"","createTime":1653301833072,"description":" 介绍\n\nMobx-state-tree（简称MST）是基于mobx的响应式状态管理工具，核心思想就是一个动态树，每个树由一个结构和一个状态组成，支持状态的序列化、反序列化、时间旅行等功能。\n\n 使用\njs\nnpm install mobx mobx-state-tree --save\n\n或\njs\nyarn add mobx mobx-state-tree\n\n\n","id":"fbf0032a-b12f-422e-b042-e2b2f76bd7d8","isDeleted":false,"likeCount":0,"name":"Mobx-state-tree介绍","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["Mobx-state-tree","MST"],"updateTime":1655884512933,"viewCount":178},{"content":"","createTime":1655800312939,"description":"很多页面滚动之后刷新页面会发现页面自动定位到了滚到的位置，但是有些交互需要刷新之后滚动到顶部，可以使用提供的*History.scrollRestoration *实现这个功能.\n\n+ \u003ccode\u003eauto\u003c/code\u003e: 将恢复用户已滚动到的页面上的位置。\n+ \u003ccode\u003emanual\u003c/code\u003e: 不还原页面上的位置，需要手动滚动。\n\njs\nif (history.scrollRest","id":"95e5f155-0a22-4bad-b6b6-3f81fa1fe2ac","isDeleted":false,"likeCount":0,"name":"History.scrollRestoration - 滚动恢复","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["scrollRestoration"],"updateTime":1655800347268,"viewCount":54},{"content":"","createTime":1655101892431,"description":"git commit报错：\njs\nnpm ERR! could not determine executable to run\n\nnpm ERR! A complete log of this run can be found in:\n\n可以删除.git目录下的hooks目录\njs\nm -rf .git/hooks\nnpm install\n","id":"a83733f2-0e08-4413-946e-0fb511c72e07","isDeleted":false,"likeCount":0,"name":"npm ERR! could not determine executable to run","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["npm","git"],"updateTime":1655101900342,"viewCount":59},{"content":"","createTime":1654401459954,"description":"安装brew时\nshell\n/bin/bash -c \"$(curl -fsSL https:raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n如果报错\nshell\nHEAD is now at 8175e404e Merge pull request 7942 from sjackman/bottl","id":"1ca537da-471f-4bbc-91a5-f802f3a36021","isDeleted":false,"likeCount":0,"name":"brew 报错 error: Not a valid ref: refs/remotes/origin/master 的解决方法","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["brew","安装","Not a valid ref"],"updateTime":1654401504964,"viewCount":74},{"content":"","createTime":1654046061196,"description":"\n 依赖注入在程序编写中常用于解决耦合问题，减少代码的复杂性，。\n\n在电商网站上买东西，下完单后就需要支付，可以选择微信、支付宝、信用卡等方式。最开始只有微信支付。\n\njs\nclass Order {\n  \n   微信支付\n  wechatPay() {\n    new WeChatPay().pay();\n  }\n  \n}\n\n\n一段时间之后需要接入支付宝、信用卡。每新增一种支","id":"9b0936a9-2557-4ce0-a4ba-3e67e405c023","isDeleted":false,"likeCount":0,"name":"依赖注入","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["依赖注入"],"updateTime":1654047697168,"viewCount":56},{"content":"","createTime":1653617042188,"description":"在写npm包的时候需要在脚本的第一行写上 !/usr/bin/env node ，用于指明该脚本文件要使用node来执行。\n\n/usr/bin/env 用来告诉用户到哪个目录下去寻找node，!/usr/bin/env node 可以让系统动态的去查找node，以解决不同机器不同用户设置不一致问题。\n\nPS： 该命令必须放在第一行， 否者不会生效","id":"807a7ba4-2cac-4b99-a926-c0bb590a6129","isDeleted":false,"likeCount":0,"name":"#!/usr/bin/env node的理解","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["/usr/bin/env","node"],"updateTime":1653617097293,"viewCount":72},{"content":"","createTime":1653616780770,"description":"替换下载链接的域名为\n\nvscode.cdn.azure.cn\n\n","id":"2dc0659e-57e4-480d-922e-55a1c050dde2","isDeleted":false,"likeCount":0,"name":"vscode 下载慢解决方案","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["vscode","下载慢"],"updateTime":1653616780770,"viewCount":48},{"content":"","createTime":1653616647381,"description":"本文主要介绍自己在使用v2ray进行反向代理过程中。安装请参考官网[安装](https:www.v2ray.com/chapter_00/install.html)，主要实现通过中间服务器访问家里电脑上运行的服务。\n\n\n\n 原理\n\n- 假设在主机 A 中有一个网页服务器，这台主机没有公网 IP，无法在公网上直接访问。另有一台主机 B，它可以由公网访问。现在我们需要把 B 作为入口，把流","id":"06a15352-9328-4916-9524-7d158dcf4088","isDeleted":false,"likeCount":0,"name":"v2ray反向代理","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["v2ray","代理"],"updateTime":1653616647381,"viewCount":81},{"content":"","createTime":1636124621057,"description":"\n 判断文件是否存在\nfunc DirExist(path string) (bool, error) {\n\t_, err := os.Stat(path)\n\tif err == nil {\n\t\treturn true, nil\n\t}\n\t 判断报错是否是因为文件不存在引起的\n\tif os.IsNotExist(err) {\n\t\treturn false, nil\n\t}\n\treturn","id":"515a02b7-68e4-49e8-9673-dd6bc4597875","isDeleted":false,"likeCount":0,"name":"golang判断文件夹是否存在","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1653016156888,"viewCount":52},{"content":"","createTime":1652795036062,"description":"\u003e在画图工具中需要判断两个矩形是否相交\n\n\u003cimg src=\"https:static.vwood.xyz/blog/WX20220517-213452@2x.png\" style=\"zoom:40%\"\u003e\n\n如上有两个矩形，中心点分别为O1(x1、y1)、O2(x2、y2)，宽高分别为(w1、h1)和(w2、h2)；\n\n要判断两个矩形是否相交，可以判断矩形的两个中心点的水平垂直距离是否小于(w","id":"ca307ea2-ce5f-46ea-8fdb-95fad4fd725b","isDeleted":false,"likeCount":0,"name":"判断两个矩形相交","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["矩形","相交"],"updateTime":1652796955794,"viewCount":74},{"content":"","createTime":1638108061787,"description":"写文章有时需要配图，就收集了几个免费的图片网站，整理如下，有新的再添加。\n\n1. 配图 [https:unsplash.com/ ](https:unsplash.com/ )   自带API\n2. [https:wallpapershome.com/](https:wallpapershome.com/)\n3. [https:wallpapertag.com/](https:","id":"612e18f4-08d7-43c8-8fef-bc5162c4ca1c","isDeleted":false,"likeCount":0,"name":"免费的图片下载网站","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["免费图片","图片","免费"],"updateTime":1652796777828,"viewCount":57},{"content":"","createTime":1652236038127,"description":"oninput、onchange，onblur的执行时机\n\n oninput\n\n输入数据的时候触发\n\n onchange\n\n值发生改变鼠标失焦后触发，在onblur之前","id":"a52d4239-28cb-4664-a6e9-41185883c913","isDeleted":false,"likeCount":0,"name":"oninput、onchange，onblur的执行时机","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["oninput","onchange"],"updateTime":1652236038127,"viewCount":74},{"content":"","createTime":1639749255267,"description":"以前看很多博客文章，都用mac的窗口样式把图片或者文章包裹起来，话空闲时间自己也做了一个\n\n效果如下：\n\u003cimg src=\"https:static.vwood.xyz/blog/WX20211217-215252@2x.png\" style=\"zoom: 0.5\"/\u003e\n\n安装：\njs\nnpm install -S vwin-eazy-win\n\n使用方式:\n\njsx\nimpo","id":"e29e4fd7-0d1e-441b-ac98-d5fe674eb865","isDeleted":false,"likeCount":0,"name":"mac窗口的插件vwin-eazy-win","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["mac","窗口"],"updateTime":1651806243220,"viewCount":125},{"content":"","createTime":1651221218801,"description":"\n\n是由于空格、换行引起的\n\n\n \u003cdiv class=\"container\"\u003e\n        \u003cspan class=\"item\"\u003e131313131313131\u003c/span\u003e\n        \u003cspan class=\"item\"\u003e131313131313131\u003c/span\u003e\n        \u003c!-- \u003cdiv class=\"subfix\"\u003e\u003c/div--\u003e\n      \u003c/div\u003e","id":"c15302a1-bf8c-486a-a40b-020db96cbbc6","isDeleted":false,"likeCount":0,"name":"html  行内元素引起的空白间距问题","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1651221218801,"viewCount":77},{"content":"","createTime":1636124890100,"description":"\n本文主要是结合自己在学习中使用css来实现图片的宽高自适应，并给出相应的结局方案。\n\n 场景\n\n给定一系列图片，图片宽高不等，每行所展示的图片数量不等，如何实现图片的自适应。\n\n\n\n 实现方法\n\n聪明的你肯定会想到使用flex布局，并且设置flex-wrap: wrap。但如何做到自适应宽度呢：\n\n我们假设图片原始宽度、高度分别为width、heigh","id":"3891106a-2cff-4d0d-8efb-1930d43d48bc","isDeleted":false,"likeCount":0,"name":"如何使用css实现图片宽高自适应","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1650763026249,"viewCount":85},{"content":"","createTime":1650615253403,"description":"[臆病な魔女](https:www.yui540.graphics/site)","id":"3cd3d279-0893-4965-9876-199955b92ec5","isDeleted":false,"likeCount":0,"name":"动画惊艳的网站","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["动画","惊艳","好看"],"updateTime":1650615266935,"viewCount":76},{"content":"","createTime":1636124774866,"description":"\n\n\n在公司构建用户个人站点的过程中使用使用到了模版template，在此总结一下\n\n\n\n 一、为什么要使用静态页面\n\n 页面应用对于在站点SEO方面存在局限性，而用户又希望可以通过SEO来增加网站的权重，所以使用了静态页面\n\n\n\n 二、解析过程\n\n用到的函数\n\ngolang\nfunc (t *Template) New(name string) *Template\n","id":"fed62dd1-74a4-4b6d-9ae7-4be678e1e6f2","isDeleted":false,"likeCount":0,"name":"golang模版解析","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["template"],"updateTime":1650613834346,"viewCount":70},{"content":"","createTime":1650609793416,"description":"使用jsonb_set函数\nsql\nUPDATE tbl_article SET data=jsonb_set(data, '{name}', 'value', true);\n\n其中data为jsonb数据格式，更新的字段名为name，值为value","id":"00921fd5-9d20-430d-a5a8-bb2b73110480","isDeleted":false,"likeCount":0,"name":"pgsql更新jsonb数据","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["pgsql","jsonb","更新"],"updateTime":1650612639555,"viewCount":75},{"content":"","createTime":1636124941393,"description":" 判断点是否在闭合曲线内\n\n以前在做医疗靶区勾画时用到过这个算法，现在总结一下，介绍引射线法。\n 1、原理\n\n从目标点引一条射线，判断这条线与曲线的交点个数为奇数还是偶数，为奇数表示点在曲线内，偶数表示点在曲线外。\n\n![](https:img-blog.csdnimg.cn/img_convert/586f98f2725f67b7b94b6cbbf1a85406.png)\n\n\n","id":"6e887be0-491d-437b-a554-dae164940cbb","isDeleted":false,"likeCount":0,"name":"判断一个点是否在闭合曲线内","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["闭合","js"],"updateTime":1650609903467,"viewCount":84},{"content":"","createTime":1637589268526,"description":"\ngit checkout master  要覆盖的分支\ngit reset --hard dev  用本地的dev覆盖master\ngit push origin master --force  推送到远程仓库\n","id":"3ae42760-f417-4778-9dee-fe6a7c857334","isDeleted":false,"likeCount":0,"name":"git覆盖分支","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["git"],"updateTime":1650586340679,"viewCount":51},{"content":"","createTime":1638019490396,"description":" css var()的使用\n\nvar()函数可以代替元素中任何属性中的值的任何部分\n\n\nvar( \u003ccustom-property-name, \u003cdeclaration-value\u003e? )\n\n\n+ 第一个参数为自定义属性值的名称\n+ 后面的value表示第一个属性值无效时的默认值\n\n\n\ncss\n.component {\n  --text-color: 080;\n}\n","id":"e304071f-dfe3-4b90-aead-14ed5249f72e","isDeleted":false,"likeCount":0,"name":"css var()的使用","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["css","换行"],"updateTime":1650538156864,"viewCount":71},{"content":"","createTime":1638108132937,"description":"\n以前用disqus作为评论，由于墙的原因导致无法访问，就一直没有加上新的评论系统，国内的评论系统有些已经关掉了，也无法使用，所以就想自己写一个简单的评论系统，只是实现了最基本的功能，还有大量的工作没有做。先整理成如下笔记。\n\n 一、设计\n\n+ 前端\n\n  + 前端只需引入一个js文件就直接可以使用，类似disqus\n  + 一个用户多个站点的评论分别保存，不互相干扰\n  + 评论只有","id":"fbe0f089-a2dd-49d5-acad-d3cdd8e35aae","isDeleted":false,"likeCount":0,"name":"记一次评论系统开发过程","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1650512551354,"viewCount":62},{"content":"","createTime":1647057305960,"description":"antd upload 组件上传时有时会报如下错误\n\nantd upload  Provisional headers are shown\n\n在请求头中添加如下代码\njs\n'X-Requested-With': null\n\n表示使用传统的同步请求","id":"0fa6f565-0ef1-4cce-aad1-81a79e0bb43d","isDeleted":false,"likeCount":0,"name":"antd upload  Provisional headers are shown","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1650512072627,"viewCount":44},{"content":"","createTime":1638108162541,"description":"在写npm脚本的时候需要在脚本的第一行写上\u003ccode\u003e!/usr/bin/env node\u003c/code，用于指明该脚本文件要使用node来执行。\n\n\u003ccode\u003e/usr/bin/env\u003c/code\u003e 用来告诉用户到path目录下去寻找node，\u003ccode\u003e!/usr/bin/env node\u003c/code\u003e 可以让系统动态的去查找node，已解决不同机器不同用户设置不一致问题。\n\nPS： 该","id":"9d0c9024-c867-4764-84b6-bc899260cc3d","isDeleted":false,"likeCount":0,"name":"#!/usr/bin/env node的理解","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1650512009698,"viewCount":70},{"content":"","createTime":1638107992736,"description":"css\n.text1 {\n/*单行*/\n\n  width:200px;\n  overflow:hidden;\n  text-overflow:ellipsis;\n  -o-text-overflow:ellipsis;\n  -webkit-text-overflow:ellipsis;\n  -moz-text-overflow:ellipsis;\n  white-space:nowrap;\n","id":"a21482f9-6b85-4bdb-b652-19d115b9080d","isDeleted":false,"likeCount":0,"name":"css行数限制","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1650511920007,"viewCount":87},{"content":"","createTime":1636124983377,"description":"Resize Observer是一个新的JavaScript API，与[Intersection Observer API](https:alligator.io/js/intersection-observer/)、[Mutation Observer](https:developer.mozilla.org/en-US/docs/Web/API/M","id":"b91d22df-cec2-4ee0-b23b-89e7e43a3cc1","isDeleted":false,"likeCount":0,"name":"Resize Observer使用","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1650511824631,"viewCount":85},{"content":"","createTime":1637074763578,"description":"当目录下有数据是，是有fs.rmdirSync会报错，需要递归\njavascript\nvar rmdir = function (dir) {\n  const isExist = fs.existsSync(dir);\n  if (!isExist) {\n    return;\n  }\n  var list = fs.readdirSync(dir);\n  for (var i = 0; i","id":"da2dadc4-5ca9-4acc-bad0-8898bec5e7c6","isDeleted":false,"likeCount":0,"name":"nodejs删除目录","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1650511802773,"viewCount":51},{"content":"","createTime":1636124649492,"description":"使用 hyphens 进行单词换行\n\n一般换行使用 word-break\n\n+ break-all：单词会被强行断开，不方便阅读\n+ break-word： 当空间不够时，单词会自动换行到下一行\n\n\n\n通常的英文排版都会合理应用所有空间，可以给没写完的那个单词使用“-”连接起来，hyphens可以实现这种效果。hyphens可选值:\n\n+ none: 单词不","id":"cdc1502c-9da9-4b4c-9a10-ec5615e69705","isDeleted":false,"likeCount":0,"name":"hyphens换行","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1650511758015,"viewCount":43},{"content":"","createTime":1650510288910,"description":"\n\n滚动加载数据就是说在达到某个条件的时候自动触发加载数据的动作，通常是滚动到页面底部的时候加载数据；\n\n代码如下：\n\njs\n  handleScroll = (e) ={\n    let layout = document.getElementById(\"layout\");\n\n    if (layout.clientHeight + layout.scrollTop \u003e= layou","id":"131d0d16-5692-403b-b949-87426c3d3f47","isDeleted":false,"likeCount":0,"name":"js 实现滚动加载数据","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1650511609868,"viewCount":76},{"content":"","createTime":1650451098855,"description":"\nchrome.storage提供了插件开发所需要的api\n\n+ local: 存储在本地\n+ sync: 会自动同步数据到用户的账号，如果用户下线就跟local一样保存在本地，上线后自动同步数据\n+ session：存储数据到会话中，不会持久化道本地，浏览器关闭后消失。\n+ managed: 只读存储，只有域管理员能够在其中存储数据，插件不能读取器中的数据\n\n\n\njs\n set","id":"961a81a0-23c0-49b1-96bc-5f8b9ceb4408","isDeleted":false,"likeCount":0,"name":"chrome插件开发（三）- 数据存储的那些事儿","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1650451660332,"viewCount":103},{"content":"","createTime":1650419679120,"description":"\n 一、content向background发送消息\n\njs\n content.js\nchrome.runtime.sendMessage(data, (response) ={\n  console.log(response)\n});\n\n\njs\nbackground.js\nchrome.runtime.onMessage.addListener((message","id":"9c53ce79-0709-4240-a660-90d07957c091","isDeleted":false,"likeCount":0,"name":"Chrome 插件开发（二）- content.js与background.js之间互相通信","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1650419685587,"viewCount":124},{"content":"","createTime":1650367830587,"description":"\n\n在background.js文件中使用 chrome.tabs.captureVisibleTab 就可以截取页面，[captureVisibleTab](https:developer.chrome.com/docs/extensions/reference/tabs/method-captureVisibleTab) 方式返回一个Promise;\n\ncaptureVi","id":"e0018cea-bce8-49ce-8ed8-07fa133ccd13","isDeleted":false,"likeCount":0,"name":"Chrome 实现插件截屏","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1650367952660,"viewCount":75},{"content":"","createTime":1650353584993,"description":"M1芯片安装依赖的时候会报错：\n\n\n\u003c--- JS stacktrace ---\u003e\n\nFATAL ERROR: wasm code commit Allocation failed - process out of memory\n 1: 0x10431b740 node::Abort() [/Users/xxx/.nvm/versions/node/v14.16.0/bin/node]\n 2","id":"d649dced-2061-462c-b9bb-cae7b8a28873","isDeleted":false,"likeCount":0,"name":"nodejs在M1报错","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1650353584993,"viewCount":77},{"content":"","createTime":1648286545073,"description":"js\n \u003ca\n   href=\"skype:xxxx?chat\"\n \ttarget=\"_blank\"\n    rel=\"noreferrer\"\n    \u003e\n\u003c/a   \n\n更换用户名即可","id":"dca13c42-ae64-4bc6-b7ab-88bcfd223e53","isDeleted":false,"likeCount":0,"name":"js 打开skype","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1649127056822,"viewCount":86},{"content":"","createTime":1649126701865,"description":"\nnextjs有时需要直接导出跟后端没有数据交互的页面，直接在package.json中添加:\n\njson\n\"export\": \"next build \u0026\u0026 next export\"\n\n\n然后执行\n\nshell\nnpm run export\n\n\n就会在根目录下生成out文件夹，out目录下的就是生成的静态文件","id":"2e930fbe-4de2-4730-aa09-d8bc3b8a0b4b","isDeleted":false,"likeCount":0,"name":"Nextjs 导出静态页面","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1649126845660,"viewCount":112},{"content":"","createTime":1648871618111,"description":"网页标注实现文章收集：\n[https:mp.weixin.qq.com/s/PY3JGWAx-nVs7o5hys6ycg](https:mp.weixin.qq.com/s/PY3JGWAx-nVs7o5hys6ycg)","id":"8ea046ee-6eb4-4496-87cf-70212ca5609f","isDeleted":false,"likeCount":0,"name":"网页标注实现","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1648871655953,"viewCount":78},{"content":"","createTime":1648283728143,"description":"js\n \u003ca\n \thref=\"https:api.whatsapp.com/send?phone=+xxxx\u0026text=Hello\"\n \ttarget=\"_blank\"\n    rel=\"noreferrer\"\n    \u003e\n \u003c/a   \n\n将其中的电话号码换了即可","id":"09022725-b8c8-4f24-80ad-450002f0bcb6","isDeleted":false,"likeCount":0,"name":"js 打开WhatsApp应用","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1648283728143,"viewCount":48},{"content":"","createTime":1636124673209,"description":"css实现文子颜色动态变化\n\n先看一下实际效果\n\n![在这里插入图片描述](https:img-blog.csdnimg.cn/20200218111823722.gif)\n\n\n\n实现代码\n\ncss\n.flow {\n    height: 120px;\n    background: linear-gradient(to right, red, orange, yellow, green","id":"80a03a38-9f10-4cec-ac5d-138bd220ae3a","isDeleted":false,"likeCount":0,"name":"css实现文字颜色动态变化","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1648189572573,"viewCount":92},{"content":"","createTime":1646962386685,"description":"1. 《虫师》\n2. 上载新生\n3. v2ex的记录 [https:www.v2ex.com/t/839674?p=1](https:www.v2ex.com/t/839674?p=1)","id":"4daaa47c-b442-4fab-9047-4c4eb7bbe493","isDeleted":false,"likeCount":0,"name":"好看的动漫、电视、电影","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1647345121254,"viewCount":104},{"content":"","createTime":1638020962954,"description":" minio 安装过程\n\n\n\n在使用minio前试过nextcloud，反复折腾后有问题，就转向了minio，minio的安装还是非常顺利\n\n\n\nDocker-compose.yml\n\nyml\n  minio:\n    image: \"minio/minio\"\n    hostname: minio\n    restart: always\n    volumes:\n      - ","id":"6691aca2-4e55-4403-a656-bd82eb45a5db","isDeleted":false,"likeCount":0,"name":"minio 安装过程","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1647010395711,"viewCount":132},{"content":"","createTime":1637842797745,"description":"prefers-reduced-motion 用于检测用户的系统是否开始了动画减弱功能。是一个css媒体查询特性\n\n\n\n 值\n\n+ reduce： 用户开启了动画减弱功能\n+ no-preference： 用户未修改系统动画相关特性\n\n\n\ncss\n 设置动画效果\n.animation {\n  animation: vibrate 0.3s linea","id":"a151a545-ff9c-4403-85b1-bb82cbb90ffd","isDeleted":false,"likeCount":0,"name":"prefers-reduced-motion 媒体查询特性","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1641482490615,"viewCount":63},{"content":"","createTime":1636120113781,"description":"最近在做一个主页时需要用国际化，用HTML+JS，还有jQuery, 于是就选择了jquery.i18n.properties.js。本文介绍的示例还依赖jquery、jquery.json。\n\n 介绍\n\njquery.i18n.properties是一款轻量级的国际化插件，采用.properties文件来对javascript文件进行国际化，即根据用户指定的语言和国家编码来解析对应的","id":"ab32d3ed-a398-4594-ade7-1c076303eda8","isDeleted":false,"likeCount":0,"name":"jquery.i18n.properties的使用讲解与实例","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1641482342572,"viewCount":123},{"content":"","createTime":1636124748710,"description":"在终端里输入如下命令\ncode\nsudo killall -STOP -c usbd\n\n\n以上本人亲测有效，如有其他解决方案，欢迎交流","id":"abbeb4b0-aea7-4672-bc8c-f9647a83ace6","isDeleted":false,"likeCount":0,"name":"解决iphone插上mac电脑充电不停的断开和链接问题","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1641482326774,"viewCount":120},{"content":"","createTime":1636124697841,"description":"写loading时有时需要在后面连续的出现一个点、两个点、三个点，实现方式有很多种，js、css皆有，今天分享看到的一种css实现方式。效果如下\n![在这里插入图片描述](https:img-blog.csdnimg.cn/20200217175259874.gif)\n\n代码如下：\n\ncss\n            .btn {\n                padding: 4px ","id":"2b899bff-4582-407b-9e79-f9195598e9a4","isDeleted":false,"likeCount":0,"name":"css实现打点动画","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1641482310895,"viewCount":55},{"content":"","createTime":1636124575176,"description":"\n\n 1、 效果:\n![在这里插入图片描述](https:img-blog.csdnimg.cn/20201214223350873.gifpic_center)\n\n\n 2、代码\n\ncss:\n\n\n.list {\n    display: flex;\n    flex-direction: row;\n    overflow: auto;\n    white-space: n","id":"6bc05b84-2d3f-4ed1-8de9-491f115e0765","isDeleted":false,"likeCount":0,"name":"使用scroll-snap实现吸附效果","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1641482281888,"viewCount":64},{"content":"","createTime":1637891799705,"description":" @supports  特性查询\n\n用于判断浏览器是否支持某种css功能\ncss\n@supports (display: grid) {\n  div {\n    display: grid;\n  }\n}\n@supports not (display: grid) {\n  div {\n    float: right;\n  }\n}\n\n\n[MDN](https:developer","id":"91ac3144-4431-4b4a-8c67-8df5ca86e574","isDeleted":false,"likeCount":0,"name":"@supports  特性查询","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1641482203191,"viewCount":50},{"content":"","createTime":1638108096433,"description":"有时服务器突然很卡，这时运行free发现内存占用太高，剩余内存太小\n![在这里插入图片描述](https:img-blog.csdnimg.cn/20200228223357917.png)\n运行如下命令\n\nsync\necho 1 /proc/sys/vm/drop_caches\necho 2 \u003e /proc/sys/vm/drop_caches\necho 3 \u003e /proc","id":"135c6a95-4ea0-4bc0-b4af-cb428b743b83","isDeleted":false,"likeCount":0,"name":"linux突然卡顿问题","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1641482178839,"viewCount":65},{"content":"","createTime":1640183965789,"description":"经常在脚本编写中需要使用到模版tempalte，用来静态生成文件、代码，总结如下。\n\n template中define使用\n\n在使用编写template时可以使用{{define}}{{end}}来命名模版，在模版引入时直接使用命名即可，如下：\nheader.tpl\n\ntpl\n{{define header}}\n\theader demo\n{{end}}\n\n\narticle.tpl","id":"dc34891b-d0b9-4d3b-8183-aff569cf3269","isDeleted":false,"likeCount":0,"name":"golang tempalte使用","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1641481073041,"viewCount":151},{"content":"","createTime":1639380331908,"description":"在js中有时需要生成随机数，通常会安装uuid，不是常用的话安装uuid会浪费加载资源，可以使用URL.createObjectURL(new Blob()).substr(-36)。\n\n其中URL.createObjectURL(new Blob())，生成的URL如下，只需取最后的36位随机字符串即可:\n\n![](https:static.vwood.xyz/blog/企业","id":"5afe2577-77e4-4d5d-819a-b6e7f7561d30","isDeleted":false,"likeCount":0,"name":"URL.createObjectURL(new Blob()).substr(-36)生成uuid","operator":null,"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1640616373687,"viewCount":107}],"initialMobxState":{"userStore":{"currentUser":null,"users":[],"token":"","qiniuToken":"","userCount":0,"productCount":0,"commentCount":0,"settingType":"products"},"productStore":{},"commentStore":{},"noteStore":{},"askStore":{},"stypeStore":{}},"__N_SSG":true},"page":"/blogs/[id]","query":{"id":"fbf0032a-b12f-422e-b042-e2b2f76bd7d8"},"buildId":"6npVgWeWZ_y_dhFxNsFjp","isFallback":false,"gsp":true,"appGip":true,"scriptLoader":[]}</script></body></html>