{"pageProps":{"data":{"category":null,"content":"\n> 本文主要是结合自己在学习中使用css来实现图片的宽高自适应，并给出相应的结局方案。\n\n### 场景\n\n给定一系列图片，图片宽高不等，每行所展示的图片数量不等，如何实现图片的自适应。\n\n\n\n### 实现方法\n\n聪明的你肯定会想到使用**flex**布局，并且设置**flex-wrap: wrap**。但如何做到自适应宽度呢：\n\n我们假设图片原始宽度、高度分别为**width**、**height**，首先如果没有设置任何样式，那么图片高度肯定是不一样。于是设置一个参考高度200px，这样宽度就会有剩余，那么剩下的宽度如何撑满呢，使用**flex-grow:  width * 200 / height**分别放大对应的图片（图片的放大倍数其实每张图片的宽度）。\n\n下面看一张实现后的效果:\n\n![](https://file.vwood.xyz/2022/07/11/upload_75zn1z2qlono9nx0roltdnigzszfcu39.jpeg)\n\n\n\n#### 代码（React）\n\n```javascript\n// list.jsx\nclass List extends React.Component {\n  render() {\n    return (\n      <div className={style.list}>\n        {\n          this.props.images.map((img, index) => <Item key={img.id} image={img}/>)\n        }\n      </div>\n    )\n  }\n}\n\n// item.jsx\n// 图片的参考高度设置为200px,\nclass Item extends React.Component {\n    // xxxxxx\n  render() {\n    const {\n      attributes: { url, width, height },\n    } = this.props.image;\n\n    return (\n      <div\n        className={style.imageContainer}\n        style={{\n          width: `${(width * 200) / height}px`,\n          flexGrow: (width * 200) / height,\n        }}>\n        <img\n          src={url}\n        />\n        <div\n          className=\"placeholder\"\n          style={{\n            paddingBottom: `${(height / width) * 100}%`,\n            display: loaded ? 'none' : 'block',\n          }}\n        />\n      </div>\n    );\n  }\n}\n\n```\n\n样式(scss)\n\n```scss\n.list {\n  display: flex;\n  flex-wrap: wrap;\n  &::after {\n    content: '';\n    flex-grow: 9999999;\n  }\n}\n\n.imageContainer {\n  display: inline-block;\n  margin: 4px;  \n}\n```\n\n\n\n##### **PS**\n\n上面解决了图片自适应问题，但是如果最后一行只有一张图片（或图片数量很少），最后一行的图片可能会很高，这时就可以找一个元素把剩余的空间撑起来，这样就相当于不让最后一张图片缩放或缩放的比例很小（高度维持在200px左右），使用伪元素**after**，并设置一个很大的**flex-grow**值。\n\n\n","createTime":1636124890100,"description":"\n本文主要是结合自己在学习中使用css来实现图片的宽高自适应，并给出相应的结局方案。\n\n 场景\n\n给定一系列图片，图片宽高不等，每行所展示的图片数量不等，如何实现图片的自适应。\n\n\n\n 实现方法\n\n聪明的你肯定会想到使用flex布局，并且设置flex-wrap: wrap。但如何做到自适应宽度呢：\n\n我们假设图片原始宽度、高度分别为width、heigh","headerImg":"//file.vwood.xyz/2022/07/11/upload_93g868jys6jvws4mixi2olc40hexurf4.jpg","id":"3891106a-2cff-4d0d-8efb-1930d43d48bc","isDeleted":false,"likeCount":0,"name":"如何使用css实现图片宽高自适应","operator":{"avatar":"//file.vwood.xyz/2022/07/13/upload_xtola9p0z8ctzyg5g014tfmjkokb7ydq.jpg","description":"一个懒惰、躺平的程序员","github":"https://github.com/abelce","id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1657554301664,"viewCount":154},"id":"3891106a-2cff-4d0d-8efb-1930d43d48bc","latestArticleList":[{"id":"38abab46-1f1d-47e0-9f3d-aeafdf41a0e7","name":"js 实现 LRU缓存","tags":[],"description":"","content":""},{"id":"02eea954-494c-4c35-8f80-d34e70f87807","name":"低代码文章收集","tags":[],"description":"","content":""},{"id":"f6ea6c70-76ba-40fa-9f5b-792afbf7fe8b","name":"记又拍云接入过程","tags":[],"description":"","content":""},{"id":"281b0b57-0e7e-4033-bcad-8b886535e127","name":"chrome文字定位与::target-text样式设置","tags":[],"description":"","content":""},{"id":"3b529a3e-13b9-4553-a454-13ce172dfedc","name":"bind、call、apply实现","tags":[],"description":"","content":""}]},"initialMobxState":{"userStore":{"currentUser":null,"users":[],"token":"","qiniuToken":"","userCount":0,"productCount":0,"commentCount":0,"settingType":"products"},"productStore":{},"commentStore":{},"noteStore":{},"askStore":{},"stypeStore":{}},"__N_SSG":true}