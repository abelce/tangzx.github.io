{"pageProps":{"data":{"category":null,"content":"```Resize Observer```是一个新的JavaScript API，与[```Intersection Observer API```](https://alligator.io/js/intersection-observer/)、[```Mutation Observer```](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)等其他观察者API非常相似。\n它允许在尺寸发生变化时通知元素。\n\n##### 基本用法\n--------\n\n使用Resize Observer非常简单，只需实例化一个新的ResizeObserver对象并传入一个回调函数，该函数接收观察到的条目\n\n```javascript\nconst myObserver = new ResizeObserver(entries => {\n  // iterate over the entries, do something.\n});\n```\n然后，我们可以在实例上调用```observe```并传入一个元素来观察\n```javascript\nconst someEl = document.querySelector('.some-element');\nconst someOtherEl = document.querySelector('.some-other-element');\n\nmyObserver.observe(someEl);\nmyObserver.observe(someOtherEl);\n```\n\n对于每个entry，我们都会得到一个包含```contentRect```和一个```target```属性的对象。```target```是DOM元素本身，contentRect是具有以下属性的对象：width，height，x，y，top，right，bottom和left。\n\n与元素的```getBoundingClientRect```不同，```contentRect```的```width```和```height```值不包含```padding```。```contentRect.top```是元素的顶部```padding```，contentRect.left是元素的左侧```padding```。\n\n比如要打印出被监听元素寸尺变化时```width```和```height```的值，可以像下面这样做:\n```javascript\nconst myObserver = new ResizeObserver(entries => {\n  entries.forEach(entry => {\n    console.log('width', entry.contentRect.width);\n    console.log('height', entry.contentRect.height);\n  });\n});\n\nconst someEl = document.querySelector('.some-element');\nmyObserver.observe(someEl);\n```\n\n\n##### 示例\n\n下面是一个简单的演示，以查看Resize Observer API的实际应用。\n通过调整浏览器窗口的大小来尝试一下，注意渐变角度和文本内容仅在元素的大小受到影响时才发生变化：\n\n\n\n让我们来分解这个简单的演示。首先，我们从一些简单的标记开始：\n\n```html\n<div class=\"box\">\n  <h3 class=\"info\"></h3>\n</div>\n<div class=\"box small\">\n  <h3 class=\"info\"></h3>\n</div>\n```\n样式：\n```css\n.box {\n  text-align: center;\n  height: 20vh;\n  border-radius: 8px;\n  box-shadow: 0 0 4px var(--subtle);\n\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.box h3 {\n  color: #fff;\n  margin: 0;\n  font-size: 5vmin;\n  text-shadow: 0 0 10px rgba(0,0,0,0.4);\n}\n\n.box.small {\n  max-width: 550px;\n  margin: 1rem auto;\n}\n```\n\n请注意，我们不需要将渐变背景应用于```.box```元素。\n当页面第一次加载时，resize观察者将被调用一次，然后我们将应用我们的渐变。\n现在，当我们添加下面的JavaScript代码时，就会发生奇迹了：\n\n```javascript\nconst boxes = document.querySelectorAll('.box');\n\nconst myObserver = new ResizeObserver(entries => {\n  for (let entry of entries) {\n    const infoEl = entry.target.querySelector('.info');\n    const width = Math.floor(entry.contentRect.width);\n    const height = Math.floor(entry.contentRect.height);\n\n    const angle = Math.floor(width / 360 * 100);\n    const gradient = `linear-gradient(${ angle }deg, rgba(0,143,104,1) 50%, rgba(250,224,66,1) 50%)`;\n\n    entry.target.style.background = gradient;\n\n    infoEl.innerText = `I'm ${ width }px and ${ height }px tall`;\n  }\n});\n\nboxes.forEach(box => {\n  myObserver.observe(box);\n});\n```\n\n在这里，我们使用for ... of循环遍历观察者回调中的条目，但在条目上调用forEach将工作得一样。\n请注意，我们还必须迭代可以观察的元素，并调用每个元素的观察值。\n\n####浏览器支持\n浏览器支持现在非常糟糕，只有Chrome 64+支持Resize Observer开箱即用。\n谢天谢地，我们可以同时使用polyfill。\n该polyfill基于MutationObserver API。\n\n#####参考书籍\n+ [A Look at the Resize Observer JavaScript API](https://alligator.io/js/resize-observer/)","createTime":1636124983377,"creativeType":"original","description":"Resize Observer是一个新的JavaScript API，与[Intersection Observer API](https:alligator.io/js/intersection-observer/)、[Mutation Observer](https:developer.mozilla.org/en-US/docs/Web/API/M","headerImg":"","id":"b91d22df-cec2-4ee0-b23b-89e7e43a3cc1","isDeleted":false,"likeCount":0,"name":"Resize Observer使用","operator":{"avatar":"//file.vwood.xyz/2022/07/13/upload_xtola9p0z8ctzyg5g014tfmjkokb7ydq.jpg","description":"一个懒惰、躺平的程序员","github":"https://github.com/abelce","id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1650511824631,"viewCount":159},"id":"b91d22df-cec2-4ee0-b23b-89e7e43a3cc1","latestArticleList":[{"id":"67eb1db1-28cf-4ae6-9263-5aea9cb8b55e","name":"css伪类:not用法","tags":[],"description":"","content":""},{"id":"38abab46-1f1d-47e0-9f3d-aeafdf41a0e7","name":"js 实现 LRU缓存","tags":[],"description":"","content":""},{"id":"02eea954-494c-4c35-8f80-d34e70f87807","name":"低代码文章收集","tags":[],"description":"","content":""},{"id":"f6ea6c70-76ba-40fa-9f5b-792afbf7fe8b","name":"记又拍云接入过程","tags":[],"description":"","content":""},{"id":"281b0b57-0e7e-4033-bcad-8b886535e127","name":"chrome文字定位与::target-text样式设置","tags":[],"description":"","content":""}]},"initialMobxState":{"userStore":{"currentUser":null,"users":[],"token":"","qiniuToken":"","userCount":0,"productCount":0,"commentCount":0,"settingType":"products"},"productStore":{},"commentStore":{},"noteStore":{},"askStore":{},"stypeStore":{}},"__N_SSG":true}